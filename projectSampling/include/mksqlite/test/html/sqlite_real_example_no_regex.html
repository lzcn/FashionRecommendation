
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>sqlite_real_example_no_regex</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-04-18"><meta name="DC.source" content="sqlite_real_example_no_regex.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Reading content of the logging file in one cell array</a></li><li><a href="#4">Create default SQL table, feeded by cell array</a></li><li><a href="#5">Identifying optional parameters and table update</a></li><li><a href="#6">Query some statistics</a></li><li><a href="#7">Close database</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> sqlite_real_example_no_regex
</pre><pre class="codeinput"><span class="comment">%{
</span><span class="comment">      % The logfile has folowing columns:
</span><span class="comment">      1:  Code
</span><span class="comment">      2:  Timestamp
</span><span class="comment">      3:  Mileage at start (km)
</span><span class="comment">      4:  Speed at start (km/h)
</span><span class="comment">      5:  Engine speed at start (rpm)
</span><span class="comment">      6:  Torque at start (Nm)
</span><span class="comment">      7:  Duration (in tenths of a second)
</span><span class="comment">      8:  Distance (m)
</span><span class="comment">      9:  Speed at end (km/h)
</span><span class="comment">      10: Engine speed at end
</span><span class="comment">      11: Torque at end
</span><span class="comment">
</span><span class="comment">      % Column count varies from 11 to 15, so optional columns 12 to 15
</span><span class="comment">      % are condensed to one column, which will be parsed later.
</span><span class="comment">
</span><span class="comment">      % Optional additional columns depending on "Code":
</span><span class="comment">      A:  Optional parameter 1
</span><span class="comment">      B:  Optional parameter 2
</span><span class="comment">      C:  Optional parameter 3
</span><span class="comment">      D:  Optional parameter 4
</span><span class="comment">%}</span>
</pre><h2>Reading content of the logging file in one cell array<a name="3"></a></h2><pre class="codeinput">    clear <span class="string">all</span>, close <span class="string">all</span>, clc

    fid = fopen ( <span class="string">'logfile.asc'</span>, <span class="string">'r'</span> );
    assert( fid &gt; 0 );
    colcnt = length( textscan( fid, <span class="string">''</span> ) );  <span class="comment">% Estimate the max. column count</span>
    assert( colcnt &gt;= 11 );
    frewind( fid );
    content = textscan( fid, repmat( <span class="string">'%s '</span>, 1, colcnt ), <span class="string">'collectOutput'</span>, 1 );
    content = content{1};
    fclose( fid );
</pre><h2>Create default SQL table, feeded by cell array<a name="4"></a></h2><pre class="codeinput">    sql( <span class="string">'open'</span>, <span class="string">''</span> );

    <span class="comment">% Create table with 11 standard columns</span>
    sql( [ <span class="string">'CREATE TABLE mantab ('</span> , <span class="keyword">...</span>
           <span class="string">'  Code, '</span>              , <span class="keyword">...</span>
           <span class="string">'  Timestamp, '</span>         , <span class="keyword">...</span>
           <span class="string">'  MileageStart  REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  SpeedStart    REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  EngSpeedStart REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  TorqueStart   REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  Duration      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  Distance      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  SpeedEnd      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  EngSpeedEnd   REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  TorqueEnd     REAL) '</span>] );

    <span class="comment">% Add optional columns (12..colcnt)</span>
    <span class="keyword">for</span> i = 12:colcnt
        sql( <span class="string">'ALTER TABLE mantab ADD COLUMN Optional_%d'</span>, i-11 );
    <span class="keyword">end</span>

    sql( <span class="string">'param_wrapping'</span>, 1 );  <span class="comment">% allow implicit subsequent SQL queries</span>

    <span class="comment">% Pull entire data with a charming "three-liner"</span>
    <span class="comment">% All subsequent queries in one transaction for speed (noticeable when using</span>
    <span class="comment">% an on-disc database)</span>
    sql( <span class="string">'begin'</span> );
    sql( <span class="string">'INSERT INTO mantab VALUES (?%s)'</span>, repmat( <span class="string">',?'</span>, 1, colcnt-1 ), content' );
    sql( <span class="string">'commit'</span> );
</pre><pre class="codeoutput">mksqlite Version 2.2 build: 109, ein MATLAB Interface zu SQLite
(c) 2008-2016 by Martin Kortmann &lt;mail@kortmann.de&gt;
                 Andreas Martin  &lt;andimartin@users.sourceforge.net&gt;
basierend auf SQLite Version 3.10.2 - http://www.sqlite.org
mksqlite verwendet darueber hinaus:
 - DEELX perl kompatible regex engine Version 1.3 (Sswater@gmail.com)
 - BLOSC/LZ4 1.3.0-rc3.dev zur Datenkompression (Francesc Alted / Yann Collett) 
 - MD5 Message-Digest Algorithm (RFC 1321) Implementierung von Alexander Peslyak
   
Platform: PCWIN64, little endian

</pre><h2>Identifying optional parameters and table update<a name="5"></a></h2><p>Codes B, P and V carrying acceleration values in optional columns (A,B). Adding new column and translate parameter A and B as acceleration. Code O carries acceleration value in optional column A.</p><pre class="codeinput">    optional =  { <span class="keyword">...</span>
                    { <span class="string">'"B","P","V"'</span>, <span class="string">'BPV_AccMean'</span>,    <span class="string">'BPV_AccRng'</span> },
                    { <span class="string">'"O"'</span>,         <span class="string">'O_LongAdj'</span> },
                };

    <span class="comment">% Creating new data column(s) and extract conditional parameters into them</span>
    <span class="keyword">for</span> i = 1:numel( optional )           <span class="comment">% rows of cell array 'optional'</span>
        code = optional{i}{1};
        <span class="keyword">for</span> j = 2:numel( optional{i} )    <span class="comment">% iterate used optional columns</span>
            <span class="comment">% Create additional named columns and update</span>
            colname = optional{i}{j};
            sql( <span class="string">'ALTER TABLE mantab ADD COLUMN %s REAL'</span>, colname );
            sql( <span class="string">'UPDATE mantab SET %s = Optional_%d WHERE Code IN (%s)'</span>, <span class="keyword">...</span>
                 colname, j-1, code );
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2>Query some statistics<a name="6"></a></h2><pre class="codeinput">    sql( <span class="string">'result_type'</span>, 1 );  <span class="comment">% Set result type to "struct of arrays"</span>
    [result, count, names] = sql( <span class="string">'SELECT * FROM mantab WHERE Code="B" AND BPV_AccMean&gt;30 ORDER BY BPV_AccRng'</span> );

    plot( result.BPV_AccRng / 100, <span class="string">'k-'</span>, <span class="string">'linewidth'</span>, 3 )
    title( <span class="string">'Acceleration range with means &gt; 0.3g'</span>, <span class="string">'fontsize'</span>, 12 );
    xlabel( <span class="string">'Nr.'</span> );
    ylabel( <span class="string">'Acceleration [g]'</span> );
    grid

    <span class="comment">% Omit percental fractions of codes</span>
    sql( <span class="string">'result_type'</span>, 2 );  <span class="comment">% Set result type to "cell matrix"</span>
    result = sql( [<span class="string">'SELECT Code, '</span>, <span class="keyword">...</span>
                   <span class="string">'ROUND(SUM(Distance)/(SELECT SUM(Distance) FROM mantab)*100,1) as Percentage '</span>, <span class="keyword">...</span>
                   <span class="string">'FROM mantab '</span>, <span class="keyword">...</span>
                   <span class="string">'WHERE Distance NOT NULL '</span>, <span class="keyword">...</span>
                   <span class="string">'GROUP BY 1 ORDER BY 1'</span>] )
</pre><pre class="codeoutput">
result = 

    'A'    [                 0]
    'B'    [ 9.199999999999999]
    'H'    [ 1.400000000000000]
    'K'    [ 2.300000000000000]
    'L'    [23.600000000000001]
    'O'    [                 0]
    'P'    [ 0.100000000000000]
    'S'    [                 0]
    'U'    [60.299999999999997]
    'V'    [ 3.100000000000000]
    'Z'    [                 0]

</pre><img vspace="5" hspace="5" src="sqlite_real_example_no_regex_01.jpg" alt=""> <h2>Close database<a name="7"></a></h2><pre class="codeinput">    sql( <span class="string">'close'</span> );
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
function sqlite_real_example_no_regex

%{
      % The logfile has folowing columns:
      1:  Code
      2:  Timestamp
      3:  Mileage at start (km)
      4:  Speed at start (km/h)
      5:  Engine speed at start (rpm)
      6:  Torque at start (Nm)
      7:  Duration (in tenths of a second)
      8:  Distance (m)
      9:  Speed at end (km/h)
      10: Engine speed at end
      11: Torque at end

      % Column count varies from 11 to 15, so optional columns 12 to 15
      % are condensed to one column, which will be parsed later.

      % Optional additional columns depending on "Code":
      A:  Optional parameter 1
      B:  Optional parameter 2
      C:  Optional parameter 3
      D:  Optional parameter 4
%}
    
    %% Reading content of the logging file in one cell array
    clear all, close all, clc
    
    fid = fopen ( 'logfile.asc', 'r' );
    assert( fid > 0 );
    colcnt = length( textscan( fid, '' ) );  % Estimate the max. column count
    assert( colcnt >= 11 );
    frewind( fid );
    content = textscan( fid, repmat( '%s ', 1, colcnt ), 'collectOutput', 1 );
    content = content{1};
    fclose( fid );
    
    %% Create default SQL table, feeded by cell array
    sql( 'open', '' );
    
    % Create table with 11 standard columns
    sql( [ 'CREATE TABLE mantab (' , ...
           '  Code, '              , ...
           '  Timestamp, '         , ...
           '  MileageStart  REAL, ', ...
           '  SpeedStart    REAL, ', ...
           '  EngSpeedStart REAL, ', ...
           '  TorqueStart   REAL, ', ...
           '  Duration      REAL, ', ...
           '  Distance      REAL, ', ...
           '  SpeedEnd      REAL, ', ...
           '  EngSpeedEnd   REAL, ', ...
           '  TorqueEnd     REAL) '] );
       
    % Add optional columns (12..colcnt)
    for i = 12:colcnt
        sql( 'ALTER TABLE mantab ADD COLUMN Optional_%d', i-11 );
    end

    sql( 'param_wrapping', 1 );  % allow implicit subsequent SQL queries
    
    % Pull entire data with a charming "three-liner"
    % All subsequent queries in one transaction for speed (noticeable when using
    % an on-disc database)
    sql( 'begin' );   
    sql( 'INSERT INTO mantab VALUES (?%s)', repmat( ',?', 1, colcnt-1 ), content' );
    sql( 'commit' );
           
    %% Identifying optional parameters and table update
    % Codes B, P and V carrying acceleration values in optional columns
    % (A,B). Adding new column and translate parameter A and B as
    % acceleration.
    % Code O carries acceleration value in optional column A.
    
    optional =  { ...
                    { '"B","P","V"', 'BPV_AccMean',    'BPV_AccRng' },
                    { '"O"',         'O_LongAdj' },
                };

    % Creating new data column(s) and extract conditional parameters into them
    for i = 1:numel( optional )           % rows of cell array 'optional'
        code = optional{i}{1};
        for j = 2:numel( optional{i} )    % iterate used optional columns
            % Create additional named columns and update
            colname = optional{i}{j};
            sql( 'ALTER TABLE mantab ADD COLUMN %s REAL', colname );
            sql( 'UPDATE mantab SET %s = Optional_%d WHERE Code IN (%s)', ...
                 colname, j-1, code );
        end
    end
    
    
    %% Query some statistics
    sql( 'result_type', 1 );  % Set result type to "struct of arrays"
    [result, count, names] = sql( 'SELECT * FROM mantab WHERE Code="B" AND BPV_AccMean>30 ORDER BY BPV_AccRng' );
    
    plot( result.BPV_AccRng / 100, 'k-', 'linewidth', 3 )
    title( 'Acceleration range with means > 0.3g', 'fontsize', 12 );
    xlabel( 'Nr.' );
    ylabel( 'Acceleration [g]' );
    grid
    
    % Omit percental fractions of codes
    sql( 'result_type', 2 );  % Set result type to "cell matrix"
    result = sql( ['SELECT Code, ', ...
                   'ROUND(SUM(Distance)/(SELECT SUM(Distance) FROM mantab)*100,1) as Percentage ', ...
                   'FROM mantab ', ...
                   'WHERE Distance NOT NULL ', ...
                   'GROUP BY 1 ORDER BY 1'] )
    
  %% Close database
    sql( 'close' );

##### SOURCE END #####
--></body></html>