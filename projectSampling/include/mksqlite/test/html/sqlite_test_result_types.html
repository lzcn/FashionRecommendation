
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>sqlite_test_result_types</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-04-18"><meta name="DC.source" content="sqlite_test_result_types.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Create new on-disc database</a></li><li><a href="#4">Create datasets in one transaction</a></li><li><a href="#5">Read all records as array of structs (default)</a></li><li><a href="#6">Read all records as struct of arrays</a></li><li><a href="#7">Read all records as cell array/matrix</a></li><li><a href="#8">Close database</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> sqlite_test_result_types
</pre><pre class="codeinput">    clear <span class="string">all</span>
    close <span class="string">all</span>
    clc
    dummy = mksqlite(<span class="string">'version mex'</span>);
    fprintf( <span class="string">'\n\n'</span> );
</pre><pre class="codeoutput">mksqlite Version 2.2 build: 109, ein MATLAB Interface zu SQLite
(c) 2008-2016 by Martin Kortmann &lt;mail@kortmann.de&gt;
                 Andreas Martin  &lt;andimartin@users.sourceforge.net&gt;
basierend auf SQLite Version 3.10.2 - http://www.sqlite.org
mksqlite verwendet darueber hinaus:
 - DEELX perl kompatible regex engine Version 1.3 (Sswater@gmail.com)
 - BLOSC/LZ4 1.3.0-rc3.dev zur Datenkompression (Francesc Alted / Yann Collett) 
 - MD5 Message-Digest Algorithm (RFC 1321) Implementierung von Alexander Peslyak
   
Platform: PCWIN64, little endian



</pre><h2>Create new on-disc database<a name="3"></a></h2><pre class="codeinput">    database  = <span class="string">'my_testdb'</span>;    <span class="comment">% name of the database file</span>
    table     = <span class="string">'test_table'</span>;   <span class="comment">% name of the table</span>

    NumOfSamples = 10;  <span class="comment">% amount of records to create</span>

    ruler    = [repmat( <span class="string">'-'</span>, 1, 60 ), <span class="string">'\n'</span>];  <span class="comment">% ruler</span>


    <span class="comment">% delete existing database file if any</span>
    <span class="keyword">try</span>
        <span class="keyword">if</span> exist( database, <span class="string">'file'</span> )
            delete (database);
        <span class="keyword">end</span>
    <span class="keyword">catch</span>
        error( <span class="string">'Unable to delete database'</span> );
    <span class="keyword">end</span>

    <span class="comment">% Open (create) database</span>
    mksqlite(<span class="string">'open'</span>, database);
    mksqlite(<span class="string">'PRAGMA synchronous = OFF'</span>);

    <span class="comment">% result types may be:</span>
    <span class="comment">% 0: array of structs</span>
    <span class="comment">% 1: struct of arrays</span>
    <span class="comment">% 2: (cell) matrix</span>
    mksqlite(<span class="string">'result_type'</span>, 0);  <span class="comment">% needless, since default</span>

    <span class="comment">% create table</span>
    <span class="comment">% take a look at the boolean field (you would surely never</span>
    <span class="comment">% name a column like that) and see later, how mksqlite handles</span>
    <span class="comment">% invalid MATLAB field name characters.</span>
    mksqlite( [<span class="string">'CREATE TABLE '</span> table        , <span class="keyword">...</span>
               <span class="string">'  ( Entry         CHAR(32), '</span> , <span class="keyword">...</span>
               <span class="string">'    BigFloat      DOUBLE, '</span>   , <span class="keyword">...</span>
               <span class="string">'    SmallFloat    FLOAT, '</span>    , <span class="keyword">...</span>
               <span class="string">'    Value         INT, '</span>      , <span class="keyword">...</span>
               <span class="string">'    Chars         TINYINT, '</span>  , <span class="keyword">...</span>
               <span class="string">'    "0/1-Boolean" BIT, '</span>      , <span class="keyword">...</span>
               <span class="string">'    ManyChars     CHAR(255) ) '</span>] );

    fprintf( ruler )
    fprintf( <span class="string">'Creating %d records in one single transaction\n'</span>, NumOfSamples );

    ManyChars = repmat( <span class="string">'1234567890'</span>, 1, 20 );
</pre><pre class="codeoutput">------------------------------------------------------------
Creating 10 records in one single transaction
</pre><h2>Create datasets in one transaction<a name="4"></a></h2><pre class="codeinput">    tic;
    mksqlite(<span class="string">'begin'</span>);

    <span class="keyword">for</span> idx = 1:NumOfSamples
        mksqlite( [<span class="string">'INSERT INTO '</span> table, <span class="keyword">...</span>
                   <span class="string">' (Entry, BigFloat, ManyChars) '</span>, <span class="keyword">...</span>
                   <span class="string">'  VALUES(?,?,?)'</span>], <span class="keyword">...</span>
                   sprintf(<span class="string">'Entry_%d'</span>, idx), idx, ManyChars );
    <span class="keyword">end</span>

    mksqlite(<span class="string">'commit'</span>);
    toc
    fprintf (<span class="string">'done.\n'</span>);

    fprintf (<span class="string">'Query amount of records\n'</span>)
    res = mksqlite([<span class="string">'select count(*) as count from '</span> table]);
    fprintf (<span class="string">'select count(*) returned %d\n'</span>, res.count);


    fprintf( ruler )
</pre><pre class="codeoutput">Elapsed time is 0.001766 seconds.
done.
Query amount of records
select count(*) returned 10
------------------------------------------------------------
</pre><h2>Read all records as array of structs (default)<a name="5"></a></h2><pre class="codeinput">    tic;
    mksqlite( <span class="string">'result_type'</span>, 0 );  <span class="comment">% array of structs</span>

    <span class="comment">% Introducing two further return values:</span>
    <span class="comment">% 1.: res_count is the numer of records (rows) returned</span>
    <span class="comment">% 2.: col_names is a cell array containing the (original) column</span>
    <span class="comment">%     names. Keep in mind, that MATLAB struct fields have naming</span>
    <span class="comment">%     restrictions and may thus differ from original column names.</span>
    <span class="comment">%</span>
    <span class="comment">% note: each of following queries fetch the column "value" twice</span>
    <span class="comment">%       to show how mksqlite handles duplicate fields</span>
    [res, res_count, col_names] = mksqlite( [<span class="string">'SELECT *,value FROM '</span> table] )
    a = toc;
    fprintf( <span class="string">'ready, %f seconds = %d records per second\n\n'</span>, a, int32(NumOfSamples/a) );
</pre><pre class="codeoutput">
res = 

10x1 struct array with fields:
    Entry
    BigFloat
    SmallFloat
    Value
    Chars
    X0_1_Boolean
    ManyChars
    Value_1


res_count =

    10


col_names = 

    'Entry'          'Entry'       
    'BigFloat'       'BigFloat'    
    'SmallFloat'     'SmallFloat'  
    'Value'          'Value'       
    'Chars'          'Chars'       
    '0/1-Boolean'    'X0_1_Boolean'
    'ManyChars'      'ManyChars'   
    'Value'          'Value_1'     

ready, 0.000423 seconds = 23614 records per second

</pre><h2>Read all records as struct of arrays<a name="6"></a></h2><pre class="codeinput">    tic;
    mksqlite( <span class="string">'result_type'</span>, 1 );  <span class="comment">% struct of arrays</span>
    [res, res_count, col_names] = mksqlite([<span class="string">'SELECT *,value FROM '</span> table])
    a = toc;
    fprintf (<span class="string">'ready, %f seconds = %d records per second\n\n'</span>, a, int32(NumOfSamples/a));
</pre><pre class="codeoutput">
res = 

           Entry: {10x1 cell}
        BigFloat: [10x1 double]
      SmallFloat: {10x1 cell}
           Value: {10x1 cell}
           Chars: {10x1 cell}
    X0_1_Boolean: {10x1 cell}
       ManyChars: {10x1 cell}
         Value_1: {10x1 cell}


res_count =

    10


col_names = 

    'Entry'          'Entry'       
    'BigFloat'       'BigFloat'    
    'SmallFloat'     'SmallFloat'  
    'Value'          'Value'       
    'Chars'          'Chars'       
    '0/1-Boolean'    'X0_1_Boolean'
    'ManyChars'      'ManyChars'   
    'Value'          'Value_1'     

ready, 0.000407 seconds = 24584 records per second

</pre><h2>Read all records as cell array/matrix<a name="7"></a></h2><pre class="codeinput">    tic;
    mksqlite( <span class="string">'result_type'</span>, 2 );  <span class="comment">% (cell) matrix</span>
    [res, res_count, col_names] = mksqlite([<span class="string">'SELECT *,value FROM '</span> table])
    a = toc;
    fprintf( <span class="string">'ready, %f seconds = %d records per second\n'</span>, a, int32(NumOfSamples/a) );

    fprintf(<span class="string">'done.\n'</span>);
</pre><pre class="codeoutput">
res = 

    'Entry_1'     [ 1]    []    []    []    []    [1x200 char]    []
    'Entry_2'     [ 2]    []    []    []    []    [1x200 char]    []
    'Entry_3'     [ 3]    []    []    []    []    [1x200 char]    []
    'Entry_4'     [ 4]    []    []    []    []    [1x200 char]    []
    'Entry_5'     [ 5]    []    []    []    []    [1x200 char]    []
    'Entry_6'     [ 6]    []    []    []    []    [1x200 char]    []
    'Entry_7'     [ 7]    []    []    []    []    [1x200 char]    []
    'Entry_8'     [ 8]    []    []    []    []    [1x200 char]    []
    'Entry_9'     [ 9]    []    []    []    []    [1x200 char]    []
    'Entry_10'    [10]    []    []    []    []    [1x200 char]    []


res_count =

    10


col_names = 

    'Entry'          'Entry'       
    'BigFloat'       'BigFloat'    
    'SmallFloat'     'SmallFloat'  
    'Value'          'Value'       
    'Chars'          'Chars'       
    '0/1-Boolean'    'X0_1_Boolean'
    'ManyChars'      'ManyChars'   
    'Value'          'Value_1'     

ready, 0.000452 seconds = 22127 records per second
done.
</pre><h2>Close database<a name="8"></a></h2><pre class="codeinput">    mksqlite(<span class="string">'close'</span>);
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
function sqlite_test_result_types

    clear all
    close all
    clc
    dummy = mksqlite('version mex');
    fprintf( '\n\n' );

    %% Create new on-disc database

    database  = 'my_testdb';    % name of the database file
    table     = 'test_table';   % name of the table

    NumOfSamples = 10;  % amount of records to create

    ruler    = [repmat( '-', 1, 60 ), '\n'];  % ruler

    
    % delete existing database file if any
    try
        if exist( database, 'file' )
            delete (database);
        end
    catch
        error( 'Unable to delete database' );
    end

    % Open (create) database
    mksqlite('open', database);
    mksqlite('PRAGMA synchronous = OFF');
    
    % result types may be:
    % 0: array of structs
    % 1: struct of arrays
    % 2: (cell) matrix
    mksqlite('result_type', 0);  % needless, since default

    % create table
    % take a look at the boolean field (you would surely never
    % name a column like that) and see later, how mksqlite handles
    % invalid MATLAB field name characters.
    mksqlite( ['CREATE TABLE ' table        , ...
               '  ( Entry         CHAR(32), ' , ...
               '    BigFloat      DOUBLE, '   , ...
               '    SmallFloat    FLOAT, '    , ...
               '    Value         INT, '      , ...
               '    Chars         TINYINT, '  , ...
               '    "0/1-Boolean" BIT, '      , ... 
               '    ManyChars     CHAR(255) ) '] );

    fprintf( ruler )
    fprintf( 'Creating %d records in one single transaction\n', NumOfSamples );
    
    ManyChars = repmat( '1234567890', 1, 20 );
    
    %% Create datasets in one transaction
    tic;
    mksqlite('begin');

    for idx = 1:NumOfSamples
        mksqlite( ['INSERT INTO ' table, ...
                   ' (Entry, BigFloat, ManyChars) ', ...
                   '  VALUES(?,?,?)'], ...
                   sprintf('Entry_%d', idx), idx, ManyChars );
    end

    mksqlite('commit');
    toc
    fprintf ('done.\n');

    fprintf ('Query amount of records\n')
    res = mksqlite(['select count(*) as count from ' table]);
    fprintf ('select count(*) returned %d\n', res.count);


    fprintf( ruler )

    %% Read all records as array of structs (default)
    tic;
    mksqlite( 'result_type', 0 );  % array of structs
    
    % Introducing two further return values:
    % 1.: res_count is the numer of records (rows) returned
    % 2.: col_names is a cell array containing the (original) column 
    %     names. Keep in mind, that MATLAB struct fields have naming 
    %     restrictions and may thus differ from original column names.
    %
    % note: each of following queries fetch the column "value" twice
    %       to show how mksqlite handles duplicate fields
    [res, res_count, col_names] = mksqlite( ['SELECT *,value FROM ' table] )
    a = toc;
    fprintf( 'ready, %f seconds = %d records per second\n\n', a, int32(NumOfSamples/a) );

    %% Read all records as struct of arrays
    tic;
    mksqlite( 'result_type', 1 );  % struct of arrays
    [res, res_count, col_names] = mksqlite(['SELECT *,value FROM ' table])
    a = toc;
    fprintf ('ready, %f seconds = %d records per second\n\n', a, int32(NumOfSamples/a));

    %% Read all records as cell array/matrix
    tic;
    mksqlite( 'result_type', 2 );  % (cell) matrix
    [res, res_count, col_names] = mksqlite(['SELECT *,value FROM ' table])
    a = toc;
    fprintf( 'ready, %f seconds = %d records per second\n', a, int32(NumOfSamples/a) );

    fprintf('done.\n');

    %% Close database
    mksqlite('close');

##### SOURCE END #####
--></body></html>